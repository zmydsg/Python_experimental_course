from Reversi import *  # 导入核心游戏逻辑
# 区域0: 外层四个角 (1,1), (1,8), (8,1), (8,8)
coner1 = {(1, 1), (1, 8), (8, 1), (8, 8)}
# 区域1: 最外层一圈 (除去角)
ring1 = {(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7),
         (8, 2), (8, 3), (8, 4), (8, 5), (8, 6), (8, 7),
         (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1),
         (2, 8), (3, 8), (4, 8), (5, 8), (6, 8), (7, 8)}

# 区域2: 最内层四个角 (3,3), (3,6), (6,3), (6,6)
coner3 = {(3, 3), (3, 6), (6, 3), (6, 6)}
# 区域3: 最内层一圈 (除去角)
ring3 = {(3, 4), (3, 5), (6, 4), (6, 5),
         (4, 3), (5, 3), (4, 6), (5, 6)}

# 区域4: 第二层外圈 (除去角)
ring2 = {(2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7),
         (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7),
         (3, 2), (4, 2), (5, 2), (6, 2),
         (3, 7), (4, 7), (5, 7), (6, 7)}
coner2 = {(2, 2), (2, 7), (7, 2), (7, 7)}  # 第二层外圈的角
ring2_non_coner = ring2 - coner2  # 区域4是ring2减去coner2

weight = {0: coner1, 1: ring1, 2: coner3, 3: ring3, 4: ring2_non_coner, 5: coner2}
def player(Colour, Board):
    """
    玩家AI函数，根据给定颜色和棋盘状态返回最佳落子位置。
    """
    # 获取所有可能的落子位置
    a = set(PossibleMove(Colour, Board))
    la = len(a)  # 可能落子位置的数量

    if la > 0:  # 如果有可行的落子位置
        # 遍历权重字典，按优先级从高到低选择落子区域
        for i in range(len(weight)):
            # 找出当前优先级区域中可落子的位置
            b = list(a & weight[i])
            lb = len(b)  # 当前区域中可落子位置的数量

            if lb > 0:  # 如果当前优先级区域中有可落子的位置
                c = []
                for j in range(lb):
                    # 获取目标位置 (b[j][0], b[j][1]) 周围8个格子的内容
                    neighbor_values = Neighbour(Board, b[j][0], b[j][1])
                    # 统计这些邻居中属于己方颜色的棋子数量
                    c.append(neighbor_values.count(Colour))

                # 找到己方邻居数量最多的位置
                # 如果有多个位置有相同的最大邻居数量，取第一个找到的
                max_count_index = c.index(max(c))
                return b[max_count_index]
    else:
        # 如果没有可行的落子位置，返回 (0,0) 表示跳过回合
        return (0, 0)